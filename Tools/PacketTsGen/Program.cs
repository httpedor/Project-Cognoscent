using System.Reflection;
using System.Text;
using System.Diagnostics.CodeAnalysis;
using System.Numerics;
using System.Text.Json.Serialization;

static class TsGen
{
    private static readonly Dictionary<Type, string> PrimitiveMap = new()
    {
        [typeof(string)] = "string",
        [typeof(bool)] = "boolean",
        [typeof(byte)] = "number",
        [typeof(sbyte)] = "number",
        [typeof(short)] = "number",
        [typeof(ushort)] = "number",
        [typeof(int)] = "number",
        [typeof(uint)] = "number",
        [typeof(long)] = "number", // NOTE: may exceed JS safe integer
        [typeof(ulong)] = "number", // NOTE: may exceed JS safe integer
        [typeof(float)] = "number",
        [typeof(double)] = "number",
        [typeof(decimal)] = "number",
    };

    [UnconditionalSuppressMessage("Trimming", "IL2026", Justification = "Reflection-based code generation tool; not trimming-safe.")]
    public static int Main(string[] args)
    {
        Console.WriteLine("PacketTsGen starting...");
        try
        {
            if (args.Length < 2)
            {
                Console.Error.WriteLine("Usage: PacketTsGen <Rpg.dll path> <output.ts>");
                return 2;
            }

            var rpgDllPath = args[0];
            var outPath = args[1];

            if (!File.Exists(rpgDllPath))
                throw new FileNotFoundException($"Rpg assembly not found: {rpgDllPath}");

            var asm = Assembly.LoadFrom(rpgDllPath);
            var sb = new StringBuilder();
            sb.AppendLine("/* Auto-generated by PacketTsGen. Do not edit. */");
            sb.AppendLine("/* Source: Rpg assembly - packets and enums */\n");

            // Enums to export explicitly
            WriteEnum(sb, GetRequiredType(asm, "Rpg.ProtocolId"));
            WriteEnum(sb, GetRequiredType(asm, "Rpg.DeviceType"));
            WriteEnum(sb, GetRequiredType(asm, "Rpg.StatValueType"));
            WriteEnum(sb, GetRequiredType(asm, "Rpg.FeatureUpdatePacket+FeatureUpdateType"));
            WriteEnum(sb, GetRequiredType(asm, "StatModifierType"));
            WriteEnum(sb, GetRequiredType(asm, "Rpg.MidiaType"));
            WriteEnum(sb, GetRequiredType(asm, "Rpg.EntityStatPacket+StatOp"));

            string[] knownTypes =
            [
                "Stat",
                "StatModifier",
                "Rpg.EntityRef",
                "Rpg.CreatureRef",
                "Rpg.Midia",
                "Rpg.BodyPartRef",
                "Rpg.Injury",
                "Rpg.InjuryType",
                "Rpg.BodyPart",
                "Feature",
                "Rpg.Skill",
                "System.Numerics.Vector2",
                "System.Numerics.Vector3",
            ];

            foreach (var kt in knownTypes)
            {
                if (kt.StartsWith("System."))
                {
                    WriteClass(sb, GetRequiredType(typeof(Vector2).Assembly, kt), knownTypes);
                    continue;
                }
                WriteClass(sb, GetRequiredType(asm, kt), knownTypes);
            }

            // Packets
            var packetBase = GetRequiredType(asm, "Rpg.Packet");
            var packetTypes = asm
                .GetTypes()
                .Where(t => t.IsClass && !t.IsAbstract && packetBase.IsAssignableFrom(t))
                .OrderBy(t => t.Name)
                .ToList();

            var packetInterfaceNames = new List<string>();

            foreach (var t in packetTypes)
            {
                var ifaceName = WriteClass(sb, t, knownTypes);
                packetInterfaceNames.Add(ifaceName);
            }

            if (packetInterfaceNames.Count > 0)
            {
                sb.AppendLine($"export type Packet = {string.Join(" | ", packetInterfaceNames)};\n");
            }

            Directory.CreateDirectory(Path.GetDirectoryName(outPath)!);
            File.WriteAllText(outPath, sb.ToString(), new UTF8Encoding(false));
            Console.WriteLine($"[PacketTsGen] Wrote {outPath} with {packetInterfaceNames.Count} packets.");
            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine("[PacketTsGen] ERROR: " + ex);
            return 1;
        }
    }

    private static void WriteEnum(StringBuilder sb, Type enumType)
    {
        if (!enumType.IsEnum) return;
        sb.AppendLine($"export enum {enumType.Name} {{");
        var names = Enum.GetNames(enumType);
        foreach (var name in names)
        {
            var value = Convert.ToUInt64(Enum.Parse(enumType, name));
            sb.AppendLine($"  {name} = {value},");
        }
        sb.AppendLine("}\n");
    }

    [RequiresUnreferencedCode("Uses reflection to read public fields and properties; tooling only.")]
    private static string WriteClass(StringBuilder sb, Type t, params string[] knownTypes)
    {
        // Writes a TypeScript interface for a given packet/class type and returns the interface name
        var ifaceName = t.Name; // keep same name for now
        sb.AppendLine($"export interface {ifaceName} {{");

        // Emit fields: include public fields, and also non-public fields annotated with [JsonInclude]
        var emitted = new HashSet<string>();
        foreach (var f in t.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic))
        {
            if (f.IsSpecialName) continue;
            // include if public, or if explicitly annotated with [JsonInclude]
            if (!f.IsPublic && !f.IsDefined(typeof(JsonIncludeAttribute), inherit: true)) continue;
            // skip fields with [JsonIgnore]
            if (f.IsDefined(typeof(JsonIgnoreAttribute), inherit: true)) continue;
            var name = Camel(f.Name);
            if (emitted.Contains(name)) continue;
            emitted.Add(name);
            var tsType = ToTsType(f.FieldType, knownTypes);
            sb.AppendLine($"  {name}: {tsType};");
        }

        // Emit properties: include public readable properties, and non-public properties annotated with [JsonInclude]
        foreach (var p in t.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic))
        {
            // determine if getter is available; PropertyInfo.CanRead is true if any getter exists (public or non-public)
            var getter = p.GetMethod;
            var getterPublic = getter != null && getter.IsPublic;
            if (!getterPublic && !p.IsDefined(typeof(JsonIncludeAttribute), inherit: true)) continue;
            // skip properties with [JsonIgnore]
            if (p.IsDefined(typeof(JsonIgnoreAttribute), inherit: true)) continue;
            var name = Camel(p.Name);
            if (emitted.Contains(name)) continue;
            emitted.Add(name);
            var tsType = ToTsType(p.PropertyType, knownTypes);
            sb.AppendLine($"  {name}: {tsType};");
        }

        sb.AppendLine("}\n");
        return ifaceName;
    }

    private static string ToTsType(Type t, params string[] knownTypes)
    {
        if (PrimitiveMap.TryGetValue(t, out var ts)) return ts;
        if (knownTypes.Contains(t.FullName!)) return t.Name;
        if (t.IsEnum) return t.Name;

        if (t.IsArray)
        {
            var elem = t.GetElementType()!;
            return ToTsType(elem, knownTypes) + "[]";
        }

        if (t.IsGenericType)
        {
            var def = t.GetGenericTypeDefinition();
            var args = t.GetGenericArguments();
            // Nullable<T> -> T | null
            if (def == typeof(Nullable<>))
            {
                return ToTsType(args[0], knownTypes) + " | null";
            }
            if (def == typeof(Dictionary<,>))
            {
                var key = ToTsType(args[0], knownTypes);
                var val = ToTsType(args[1], knownTypes);
                // Typescript index signatures require string/number/symbol keys
                if (key != "string" && key != "number") key = "string";
                return $"{{ [key: {key}]: {val} }}";
            }
            if (def == typeof(List<>) || def == typeof(IEnumerable<>))
            {
                return ToTsType(args[0], knownTypes) + "[]";
            }
        }

        Console.WriteLine($"[TsGen] Warning: Unmapped type {t.FullName}, defaulting to 'unknown'");
        return "unknown";
    }

    private static string Camel(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        if (name.Length == 1) return name.ToLowerInvariant();
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    [RequiresUnreferencedCode("Uses reflection to resolve types; not trimming-safe.")]
    private static Type GetRequiredType(Assembly asm, string fullName)
    {
        // Try to resolve by full name first
        var t = asm.GetType(fullName);
        if (t != null) return t;

        // Fallback: try to find a type whose simple name matches (useful for types in the global namespace)
        t = asm.GetTypes().FirstOrDefault(x => x.Name == fullName);
        if (t != null) return t;

        // Not found
        throw new InvalidOperationException($"Type not found: {fullName}");
    }
}
